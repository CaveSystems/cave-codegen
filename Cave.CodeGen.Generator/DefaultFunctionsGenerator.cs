using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cave.CodeGen.Generator;

/// <summary>
/// Source generator for default functions (Equals, GetHashCode).
/// </summary>
[Generator]
public sealed class DefaultFunctionsGenerator : IIncrementalGenerator
{
    #region Static

    static void Report(SourceProductionContext context, string id, LocalizableString title, LocalizableString messageFormat, DiagnosticSeverity severity, params object[] parameter)
    {
        var desc = new DiagnosticDescriptor(id: id, title: title, messageFormat: messageFormat, "Cave.CodeGen", severity, true);
        context.ReportDiagnostic(Diagnostic.Create(desc, Location.None, parameter));
    }

    static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol?> types)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        var watch = Stopwatch.StartNew();
        foreach (var type in types)
        {
            if (type is null)
            {
                continue;
            }

            try
            {
                var code = GenerateCode(type);
                var typeNamespace = GetNameSpace(type);
                var typeName = (typeNamespace == null ? null : $"{typeNamespace}.") + type.Name;
                var filename = $"{typeName}.g.cs";
                context.AddSource(filename, code);
            }
            catch (Exception ex)
            {
                Report(context, "CCG001", $"Codegeneration exception", "Error during generation of type {0}.\n{1}", DiagnosticSeverity.Error, type, ex);
            }
        }
    }

    static string GenerateCode(ITypeSymbol symbol)
    {
        var ns = GetNameSpace(symbol);
        var type = symbol.IsReferenceType ? "class" : "struct";
        var code = new CodeWriter();
        code.AddLine("//------------------------------------------------------------------------------");
        code.AddLine("// <auto-generated>");
        code.AddLine($"//     This code was generated by a tool at {DateTime.Now}.");
        code.AddLine("//");
        code.AddLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        code.AddLine("//     the code is regenerated.");
        code.AddLine("// </auto-generated>");
        code.AddLine("//------------------------------------------------------------------------------");
        code.AddLine();
        if (ns != null)
        {
            code.AddLine($"namespace {ns}");
        }

        code.Ident();
        {
            code.AddLine($"partial {type} {symbol.Name}");
            code.Ident();
            {
                //hash code
                GenerateHashCodeFunction(code, symbol);

                //equals
                code.AddLine();
                GenerateEqualsFunction(code, symbol);

                //IComparable
                if (symbol.Interfaces.Any(i => i.Name.StartsWith("IComparable")))
                {
                    code.AddLine();
                    GenerateComparableFunction(code, symbol);
                }
            }
            code.UnIdent();
        }
        code.UnIdent();
        return code.ToString();
    }

    static void GenerateComparableFunction(CodeWriter code, ITypeSymbol symbol)
    {
        var fieldNames = GetFields(symbol).Select(GetFieldName).Where(n => n is not null).ToArray();
        code.AddLine($"public int CompareTo({symbol.Name} other)");
        code.Ident(IdentMode.Brackets);
        code.AddLine("var comparer = new Cave.Collections.DefaultComparer();");
        code.AddLine("return");
        code.Ident(IdentMode.Tab);
        var first = true;
        foreach (var field in fieldNames)
        {
            code.StartLine();
            if (first)
            {
                first = false;
            }
            else
            {
                code.Append("|| ");
            }
            code.EndLine($"comparer.Add({field}, other.{field})");
        }
        code.AddLine($"? comparer : 0;");
        code.UnIdent();
        code.UnIdent();
    }

    static void GenerateEqualsFunction(CodeWriter code, ITypeSymbol symbol)
    {
        code.AddLine("public override bool Equals(object obj) =>");
        code.Ident(IdentMode.Tab);
        code.AddLine($"obj is {symbol.Name} other && Equals(other);");
        code.UnIdent();

        code.AddLine();
        code.AddLine($"public bool Equals({symbol.Name} other) =>");
        code.Ident(IdentMode.Tab);
        if (symbol.IsReferenceType)
        {
            code.StartLine($"other is {symbol.Name}");
        }
        foreach (var field in GetFields(symbol))
        {
            var fieldName = GetFieldName(field);
            if (fieldName is null) continue;

            if (code.Started) code.EndLine(" &&");
            var isPrimitive = field.Type.SpecialType switch
            {
                SpecialType.System_Boolean or SpecialType.System_Byte or SpecialType.System_Char or SpecialType.System_Decimal or SpecialType.System_Double or
                    SpecialType.System_Enum or SpecialType.System_Int16 or SpecialType.System_Int32 or SpecialType.System_Int64 or SpecialType.System_IntPtr or
                    SpecialType.System_SByte or SpecialType.System_Single or SpecialType.System_String or SpecialType.System_UInt16 or SpecialType.System_UInt32 or
                    SpecialType.System_UInt64 or SpecialType.System_UIntPtr => true,
                _ => false
            };
            if (isPrimitive)
            {
                code.AddLine($"// primitive {field.Type.Name}");
                code.StartLine($"({fieldName} == other.{fieldName})");
            }
            else if (field.Type.IsValueType)
            {
                code.AddLine($"// value type {field.Type.Name}");
                code.StartLine($"{fieldName}.Equals(other.{fieldName})");
                continue;
            }
            else
            {
                code.AddLine($"// {field.Type.Name}");
                code.StartLine($"((this.{fieldName} is null && other.{fieldName} is null) || {fieldName}.Equals(other.{fieldName}))");
            }
        }
        code.EndLine(";");
        code.UnIdent();
    }

    static void GenerateHashCodeFunction(CodeWriter code, ITypeSymbol symbol)
    {
        var fieldNames = GetFields(symbol).Select(GetFieldName).Where(n => n is not null).ToArray();
        code.AddLine("public override int GetHashCode()");
        code.Ident(IdentMode.Brackets);
        code.AddUnidentedLine("#if HASHING_USE_CRC32");
        code.AddLine($"var hash = new Cave.Crc32();");
        code.AddUnidentedLine("#elif HASHING_USE_FRAMEWORK && (NETSTANDARD2_1_OR_GREATER || NET5_0_OR_GREATER)");
        code.AddLine($"var hash = new System.HashCode();");
        code.AddUnidentedLine("#elif HASHING_USE_USERFUNCTION");
        code.AddLine($"var hash = Cave.DefaultHashingFunction.Create();");
        code.AddUnidentedLine("#else");
        code.AddLine($"var hash = new Cave.XxHash32();");
        code.AddUnidentedLine("#endif");
        foreach (var field in fieldNames)
        {
            code.AddLine($"hash.Add({field});");
        }
        code.AddLine($"return hash.ToHashCode();");
        code.UnIdent();
    }

    static string? GetFieldName(IFieldSymbol symbol) => symbol.CanBeReferencedByName ? symbol.Name : symbol.AssociatedSymbol?.Name;

    static IList<IFieldSymbol> GetFields(ITypeSymbol type)
    {
        var members = type.GetMembers();
        var fields = members.Where(m => m is IFieldSymbol f && !f.HasConstantValue).Cast<IFieldSymbol>().ToList();
        return fields;
    }

    static string? GetNameSpace(ITypeSymbol type) => type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToString();

    static ITypeSymbol? GetSymbolNameOrNull(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;
        if (attributeSyntax.Parent?.Parent is not TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return null;
        }

        if (!typeDeclarationSyntax.IsKind(SyntaxKind.ClassDeclaration) && !typeDeclarationSyntax.IsKind(SyntaxKind.StructDeclaration))
        {
            return null;
        }

        return ModelExtensions.GetDeclaredSymbol(context.SemanticModel, typeDeclarationSyntax, cancellationToken) as ITypeSymbol;
    }

    static bool IsAffected(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is AttributeSyntax attribute)
        {
            var name = attribute.Name switch
            {
                SimpleNameSyntax sns => sns.Identifier.Text,
                QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                _ => null
            };
            return name is "GenerateDefaultFunctions";
        }

        return false;
    }

    static void LaunchDebugger()
    {
#if DEBUGGING
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }
#endif
    }

    #endregion

    #region IIncrementalGenerator Members

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        LaunchDebugger();
        var types = context.SyntaxProvider.CreateSyntaxProvider(IsAffected, GetSymbolNameOrNull).Where(t => t is not null).Collect();
        context.RegisterSourceOutput(types, GenerateCode);
    }

    #endregion
}
