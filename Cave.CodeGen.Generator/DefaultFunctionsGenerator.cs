using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cave.CodeGen.Generator;

[Generator]
public sealed class DefaultFunctionsGenerator : IIncrementalGenerator
{
    #region Static

    static void GenerateCode(SourceProductionContext context, ImmutableArray<ITypeSymbol?> types)
    {
        if (types.IsDefaultOrEmpty)
        {
            return;
        }

        foreach (var type in types)
        {
            if (type is null)
            {
                continue;
            }

            try
            {
                var code = GenerateCode(type);
                var typeNamespace = GetNameSpace(type);
                var typeName = (typeNamespace == null ? null : $"{typeNamespace}.") + type.Name;
                context.AddSource($"{typeName}.g.cs", code);
            }
            catch (Exception ex) { Console.Error.WriteLine(ex); }
        }
    }

    static string GenerateCode(ITypeSymbol symbol)
    {
        var ns = GetNameSpace(symbol);
        var type = symbol.IsReferenceType ? "class" : "struct";
        var code = new CodeWriter();
        code.AddLine("//------------------------------------------------------------------------------");
        code.AddLine("// <auto-generated>");
        code.AddLine("//     This code was generated by a tool.");
        code.AddLine("//");
        code.AddLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        code.AddLine("//     the code is regenerated.");
        code.AddLine("// </auto-generated>");
        code.AddLine("//------------------------------------------------------------------------------");
        code.AddLine($"using Cave.CodeGen;");
        code.AddLine();
        if (ns != null)
        {
            code.AddLine($"namespace {ns}");
        }

        code.Ident();
        code.AddLine($"partial {type} {symbol.Name}");
        code.Ident();
        var fieldNames = GetFieldNames(symbol);
        GenerateHashCodeFunction(code, symbol, fieldNames);
        code.AddLine();
        GenerateEqualsFunction(code, symbol, fieldNames);
        code.UnIdent();
        code.UnIdent();
        return code.ToString();
    }

    static void GenerateEqualsFunction(CodeWriter code, ITypeSymbol symbol, IEnumerable<string> fieldNames)
    {
        code.AddLine("public override bool Equals(object obj) =>");
        code.Ident(IdentMode.Tab);
        code.AddLine($"obj is {symbol.Name} other && Equals(other);");
        code.UnIdent();

        code.AddLine();
        code.AddLine($"public bool Equals({symbol.Name} other) =>");
        code.Ident(IdentMode.Tab);
        code.StartLine(symbol.IsReferenceType ? $"other is {symbol.Name}" : "true");
        foreach (var field in fieldNames)
        {
            code.Append(" &&");
            code.EndLine();
            code.StartLine();
            code.Append($"Equals(other.{field}, this.{field})");
        }
        code.EndLine(";");
        code.UnIdent();
    }

    static void GenerateHashCodeFunction(CodeWriter code, ITypeSymbol symbol, IEnumerable<string> fieldNames)
    {
        var fieldList = string.Join(", ", fieldNames);
        code.AddLine("public override int GetHashCode() =>");
        code.Ident(IdentMode.Tab);
        code.AddLine($"Crc32.GetHashCode({fieldList});");
        code.UnIdent();
    }

    static IList<string> GetFieldNames(ITypeSymbol type)
    {
        var fields = GetFields(type);
        return fields.Select(f => f.CanBeReferencedByName ? f.Name : f.AssociatedSymbol?.Name ?? string.Empty).Where(s => s != string.Empty).ToList();
    }

    static IList<IFieldSymbol> GetFields(ITypeSymbol type)
    {
        var members = type.GetMembers();
        var fields = members.Where(m => m is IFieldSymbol).Cast<IFieldSymbol>().ToList();
        return fields;
    }

    static string? GetNameSpace(ITypeSymbol type) => type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToString();

    static ITypeSymbol? GetSymbolNameOrNull(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;
        if (attributeSyntax.Parent?.Parent is not TypeDeclarationSyntax typeDeclarationSyntax)
        {
            return null;
        }

        if (!typeDeclarationSyntax.IsKind(SyntaxKind.ClassDeclaration) && !typeDeclarationSyntax.IsKind(SyntaxKind.StructDeclaration))
        {
            return null;
        }

        return ModelExtensions.GetDeclaredSymbol(context.SemanticModel, typeDeclarationSyntax) as ITypeSymbol;
    }

    static bool IsAffected(SyntaxNode syntaxNode, CancellationToken cancellationToken)
    {
        if (syntaxNode is AttributeSyntax attribute)
        {
            var name = attribute.Name switch
            {
                SimpleNameSyntax sns => sns.Identifier.Text,
                QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                _ => null
            };
            return name is "GenerateDefaultFunctions";
        }

        return false;
    }

    static void LaunchDebugger()
    {
#if DEBUG
        if (!Debugger.IsAttached)
        {
            Debugger.Launch();
        }
#endif
    }

    #endregion

    #region IIncrementalGenerator Members

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        LaunchDebugger();
        var types =
            context.SyntaxProvider.CreateSyntaxProvider(IsAffected, GetSymbolNameOrNull).Where(t => t is not null).Collect();
        context.RegisterSourceOutput(types, GenerateCode);
    }

    #endregion
}
